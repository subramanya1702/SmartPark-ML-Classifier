# -*- coding: utf-8 -*-
"""PLV_MODULE1_PIPELEINE.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vHs5S8M8Siu6Vdqa2T74fzWEpjaL8ZN7
"""
import io
import os
import pathlib
import subprocess
import time
import uuid

import yaml
from PIL import Image
from pymongo import MongoClient

from my_utils.image_fetcher import image_fetcher
from my_utils.preprocess3 import pre_process


class RunProcess:
    __model_inputs = None
    __pre_processing_config = None
    __parking_lots = None
    __mongo_connection_string = None
    __connection_obj = None

    def __init__(self):
        with open('config/config.yml', 'r') as file:
            __sp_config = yaml.safe_load(file)

        if __sp_config is None:
            print("Error while fetching config from yml file.")
            exit(1)

        try:
            self.__model_inputs = __sp_config["model-inputs"]
            self.__pre_processing_config = __sp_config["pre-processing-bounds"]
            self.__parking_lots = __sp_config["parking-lots"]

            if os.getenv('DB_CONN_STR') is not None:
                self.__mongo_connection_string = "mongodb://" + os.getenv('DB_CONN_STR')
            else:
                self.__mongo_connection_string = __sp_config["mongodb"]["connection-string"]

            mongo_client = MongoClient(self.__mongo_connection_string)
            self.__connection_obj = mongo_client['plv_detection_data']
        except Exception:
            print("Error while parsing config.")
            exit(1)

    def __insert_to_mongodb(self, parking_lot, filename_string, number_of_empty_parking_slots, timestamp):
        pre_processed_image_file_name = os.path.join(pathlib.Path(__file__).parent.resolve(),
                                                     f"pre_processed_image/{filename_string}")
        output_image_file_name = os.path.join(pathlib.Path(__file__).parent.resolve(),
                                              f"inference/output/{filename_string}")

        og_image = Image.open(pre_processed_image_file_name)
        og_image_bytes = io.BytesIO()
        og_image.save(og_image_bytes, format='JPEG')

        pred_image = Image.open(output_image_file_name)
        pred_image_bytes = io.BytesIO()
        pred_image.save(pred_image_bytes, format='JPEG')

        common_request_body = {
            'id': str(uuid.uuid4()),
            'latitude': str(parking_lot["latitude"]),
            'longitude': str(parking_lot["longitude"]),
            'name': parking_lot["name"],
            'emptySpaces': number_of_empty_parking_slots,
            'totalSpaces': parking_lot["spaces"],
            'timestamp': int(timestamp),
            'ogImage': og_image_bytes.getvalue(),
            'predImage': pred_image_bytes.getvalue(),
            'timeLimit': parking_lot["time_limit"],
            'charges': parking_lot["charges"]
        }

        # Insert the record to ParkingLotHistory collection
        parking_lot_history_collection = self.__connection_obj['parkingLotHistory']
        parking_lot_history_collection.insert_one(common_request_body)

        # Insert the record to RecentParkingLots collection
        recent_parking_lots_collection = self.__connection_obj['recentParkingLots']
        query_filter = {
            'latitude': str(parking_lot["latitude"]),
            'longitude': str(parking_lot["longitude"])
        }
        existing_parking_lot = recent_parking_lots_collection.find_one(query_filter)

        if existing_parking_lot:
            common_request_body['_id'] = existing_parking_lot['_id']
            common_request_body['id'] = existing_parking_lot['id']
            recent_parking_lots_collection.replace_one(query_filter, common_request_body)
        else:
            recent_parking_lots_collection.insert_one(common_request_body)

        print("Records inserted to Mongodb")

        # Clean up local images after inserting to DB
        input_image_file_name = os.path.join(pathlib.Path(__file__).parent.resolve(), f"images/{filename_string}")
        os.remove(pre_processed_image_file_name)
        os.remove(input_image_file_name)
        os.remove(output_image_file_name)

    def __process2_pipeline(self, parking_lot):
        # IMAGE FETCHER SCRIPT
        fetched_image, filename_string, timestamp = image_fetcher(parking_lot["source_url"])

        # Sending the image to preprocessing script
        pre_process(self.__pre_processing_config,
                    fetched_image,
                    filename_string)

        # Setting the directory path to fetch the image for detection
        source = self.__pre_processing_config["preprocessed-image-dir-save-path"] + filename_string

        # PREDICTION part of the process pipeline
        command = [
            'python3',
            'detect.py',
            '--weights',
            self.__model_inputs["weights"],
            '--source',
            source,
            '--img-size',
            str(self.__model_inputs["img-size"]),
            '--conf-thres',
            '0.68'
        ]

        # Running the detection script
        sp = subprocess.Popen(command, stdout=subprocess.PIPE)
        output, _ = sp.communicate()

        # POST-PROCESSING Script
        print(output)
        result_string = (output.split(b'\n'))[-4]
        print(result_string)
        try:
            number_of_vehicles = int(result_string.split(b" ")[1])
            number_of_empty_parking_slots = parking_lot["spaces"] - number_of_vehicles
        except Exception:
            print("Exception while processing the model output. Setting the number of available parking slots to 0")
            number_of_empty_parking_slots = parking_lot["spaces"]

        self.__insert_to_mongodb(parking_lot, filename_string, number_of_empty_parking_slots, timestamp)

    def run(self):
        n = 0
        while True:
            print(f"Iteration {n}")
            start = time.time()

            # TODO: Execute different parking lots parallely
            for parking_lot in self.__parking_lots:
                self.__process2_pipeline(parking_lot)

            end = time.time()
            diff = end - start
            print(diff)
            time.sleep(3)
            n += 1


if __name__ == "__main__":
    run_process = RunProcess()
    run_process.run()
